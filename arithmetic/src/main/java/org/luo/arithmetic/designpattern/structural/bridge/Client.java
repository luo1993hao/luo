package org.luo.arithmetic.designpattern.structural.bridge;


/**
 * 定义：
 * 桥接模式是将抽象部分与它的实现部分分离，使它们都可以独立地变化
 * 场景：
 * 1. 一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。
 * 2.对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。
 * <p>
 * 对场景的说明：
 * 比如一个画笔，目前笔的类型有圆珠笔和铅笔。画笔颜色有红，黄，蓝。功能为画出笔的类型和颜色。
 * 如果使用正常的思维，接口为brush，方法为draw（），那么就有红色圆珠笔类，黄色圆珠笔类，蓝色圆珠笔类。红色铅笔，黄色铅笔，蓝色铅笔。3*2=6个类
 * 如果后续增加笔的颜色或者笔的类型，类的个数会急剧新增。
 * 这个场景中，画笔类就有2个独立变化的纬度，类型和颜色。并且扩展后都会导致类的个数快速增加。该场景下就适用于桥接模式。
 * <p>
 * <p>
 * 类角色：
 * 抽象化(Abstraction)角色：抽象化给出的定义，并保存一个对实现化对象的引用。 （上述场景的画笔）
 * 修正抽象化(RefinedAbstraction)角色：扩展抽象化角色，改变和修正父类对抽象化的定义。（可选，这里可以提供抽象类实现抽象角色的部分方法，
 * 提供一些默认实现，类似于jdk中list于abstractList（适配器模式的缺省模式））
 * 实现化(Implementor)角色：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，
 * 实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。（上述场景的画笔颜色）
 * 具体实现化(ConcreteImplementor)角色：这个角色给出实现化角色接口的具体实现。（上述场景的红，黄，蓝具体实现）
 * <p>
 * 该模式又叫"柄体"模式。
 * 可以理解为：抽象化角色为水杯的手柄。抽象化角色持有实现化角色的引用，可以把抽象化角色和实现看作是水杯的杯身。手柄控制杯身。
 * <p>
 * <p>
 * <p>
 * 较于其他模式：
 * 桥接模式通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。
 * 桥接、 状态模式和策略模式 （在某种程度上包括适配器） 模式的接口非常相似。
 * 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。
 * 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。
 * 设计模式并不仅是一种对类进行组织的方式， 它还能用于沟通意图
 * <p>
 * <p>
 * 源码使用：
 * jdk中driver与Connection 通过DriverManager 桥接（目前没找到标准的桥接模式在源码中的使用）
 * 个人理解：
 * 桥接模式难度大，日常开发很少用得到，学习该模式最大的好处是加深对oo的理解。
 * 其实就是一个排列组合问题。如果使用单纯继承，就是n*m个类，使用桥接模式就是n+m个类。
 * 桥接模式好处。1.减少类的个数 2.将单纯的继承改为继承+组合，将多个纬度给抽离，使类的职责单一。
 */
public class Client {
    public static void main(String[] args) {
        //蓝色圆珠笔
        Pen blueBallPointPen = new BallPointPen(new BluePenType());
        blueBallPointPen.draw();
        //红色画笔
        Pen redPaintBrush = new PaintBrush(new RedPenType());
        redPaintBrush.draw();
    }


}
