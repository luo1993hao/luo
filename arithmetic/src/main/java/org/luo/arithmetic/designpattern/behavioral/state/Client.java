package org.luo.arithmetic.designpattern.behavioral.state;

/**
 * 定义：
 * 当一个对象内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
 * 场景：
 * 你发现你的代码里面存在一个很长的if else列表，而这些分支都是因为不同状态下执行的操作不一样时考虑使用此模式
 * <p>
 * 类角色：
 * 环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。
 * 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。
 * 具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。
 * <p>
 * 优点：
 * 1. 结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。
 * 2. 将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。
 * 3. 状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。
 * 缺点：
 * 1.状态模式的使用必然会增加系统的类与对象的个数。
 * 2.不满足开闭原则。新增新的状态类需要修改状态转换的源码。
 * 源码中的使用： 无
 * 与策略模式的区别：
 * 1.状态模式的行为是平行性的，不可相互替换的；而策略模式的行为是平等性的，是可以相互替换的。
 * <p>
 * 个人理解：
 * <p>
 * 感觉状态模式是一个非常"奇怪"的设计模式。 感觉日常开发中不是很实用。大部分都可以被策略模式替代。
 * 1.作为跟策略模式类似的模式，在源码中的使用却很少。（相比于源码中大量的策略模式）。
 * 2.网上的关于状态模式的文章都说了与策略模式的区别。但是提供的代码例子感觉都可以用"策略模式"来替换。
 * <p>
 * 个人理解状态模式适用于状态之间有关联的场景。例如订单系统。订单的不同状态所产生的行为。各个状态之间是有流转，依赖，关联。
 * <p>
 * 目前我的认识还是停留在状态模式就是策略模式的"升级版本"。策略模式各个策略是完全独立的。由客户端决定。
 * 而状态模式应该是只指定初始状态，由内部决定状态的流转，从而从而改变行为。（
 * 从代码中体现为具体的状态类持有context的引用。当状态改变时，应该将context中状态改变为下一个状态，从而改变行为
 * 而策略模式中具体策略并不持有）
 * 也就是说：状态模式特定状态知道其他所有状态的存在， 且能触发从一个状态到另一个状态的转换；
 * 策略则几乎完全不知道其他策略的存在。
 */
public class Client {
    public static void main(String[] args) {
        Context context = new Context(new OneLevelState());
        context.right();
        context.right();
        context.right();
        context.left();
        context.right();
        context.right();
    }
}
