package org.luo.arithmetic.designpattern.creational.prototype;

/**
 * 定义：
 * 使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。
 * <p>
 * 场景：
 * 类结构：
 * 抽象原型(Prototype)角色：这是一个抽象角色，通常由一个Java接口或Java抽象类实现。此角色给出所有的具体原型类所需的接口。
 * <p>
 * 具体原型（Concrete Prototype）角色：被复制的对象。此角色需要实现抽象的原型角色所要求的接口。
 * <p>
 * 优点：
 * 可以更方便地生成复杂对象。
 * 可以克隆预生成原型， 避免反复运行初始化代码。
 * 缺点：
 * 克隆包含循环引用的复杂对象可能会非常麻烦。
 * <p>
 * 源码中的使用：
 * 通过继承cloneable和重写clone方法实现。
 * 个人理解：
 * 浅拷贝：jdk的cloneable
 * 深拷贝：自己new 或者序列化。
 * 个人感觉原型模式很鸡肋，在项目中很难去使用。原因如果使用jdk中原型模式。使用super的方式，为浅拷贝
 * 所有克隆的对象都指向一个引用。很可能出错
 * clone方法只能复制基本类型，对于引用类型它只是浅拷贝。遇到引用类型，我们必须要对该属性进行单独的clone。当引用类型太多时，会多出很大的工作量。也真是因为这样，所以引用类型一旦是final修饰时，我们就不能使用clone方法了。
 * 此时只能用序列化/每个引用进行new出新对象进行深拷贝。
 */
public class Client {
    //查看cloneable的实现，重写了clone方法的类都是原型模式
}
